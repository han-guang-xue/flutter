#include <stdio.h>
int main(int argc, char const *argv[])
{

    // 常用的
    printf("d %d \n", 10);
    printf("d %d \n", 10);
    printf("o %o \n", 10); //八进制打印整数值
    printf("x %x \n", 10); //以十六进制打印
    printf("c %c \n", 'c'); //打印字符
    printf("s %s \n", "abc"); //打印字符
    printf("lf %lf \n", 10.333333333); //double
    printf("ld %ld \n", 10); // 长整型
    /**
     %g用于打印浮点型数据时，会去掉多余的零，至多保留六位有效数字（不同于%e的默认保留小数点后6位）
     当%g用于打印超过6位的浮点型数据时，因为精度问题，%f不得不输出一个不精确的超过六位的数字，%e也是同样，而%g此时会选择%e格式进行输出，并且按第一条要求，去掉多余的零，并且四舍五入到6位数字。这是《C Primer Plus》中所说的超过精度的时候的情况。  （可见，这个6位，是按float类型精度来计算的。）
     当一个数字的绝对值很小的时候，要表示这个数字所需要的字符数目就会多到让人难以接受。举例而言，如果我们把π*10^-10写作0.00000000000314159就会显得非常丑陋不雅，反之，如果我们写作3.14159e-10，就不但简洁而且易读好懂。当指数是-4时，这两种表现形式大小相同。对于比较小的数值，除非该数的指数小于或者等于-5，%g才会采用科学技术发来表示，即，以%e的格式进行输出。
    */
    printf("g %g \n", 0.00000000000314159); //打印浮点值
    printf("f %f \n", 10.0); //打印浮点值
    printf("e %e \n", 0.00000000000314159); //打印浮点值
    // 其他的
    
    printf("u %u \n", -10.0); // 以十进制形式输出无符号整数
    printf("i %i \n", 10.0); // 有符号十进制整数(与%d相同)
    printf("p %p \n", 10.0); // 输出内存地址形式数据（16进制）
    printf("a %a \n", 10.0); // 浮点数、十六进制数字和p-计数法(C99)
    printf("n %n ccc\n", 10.0); // 
    printf("\n"); // 以十六进制形式输出无符号整数(不输出前缀OX)
    printf("x %x \n", 10.0); // 以十六进制形式输出无符号整数(不输出前缀OX)
    printf("X %x \n", 10.0); // 同上
    
    return 0;
}
